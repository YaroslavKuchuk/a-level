# Урок №18. LINQ

## Полезные ссылки

[LINQ](https://metanit.com/sharp/tutorial/15.1.php)

[LINQ](https://msdn.microsoft.com/ru-ru/library/bb397676(v=vs.120).aspx)

## Методы расширений

Что это и зачем?

![Extension method](/Module-3/images/extension-example.png)

Пример метода расширения

### Практика

Добавляем метод расширения для конвертации остатка на счету в строку (пример из домашки)


## LINQ

**LINQ (Language-Integrated Query)** представляет простой и удобный язык запросов к источнику данных. 

![LINQ architecture](/Module-3/images/linq-architecture.png)

В качестве источника данных может выступать объект, реализующий интерфейс IEnumerable (например, стандартные 
коллекции, массивы), набор данных DataSet, документ XML. Но вне зависимости от типа источника LINQ 
позволяет применить ко всем один и тот же подход для выборки данных.

![Разновидности LINQ](/Module-3/images/linq.png)

### Пример LINQ выражения

![Выражение LINQ](/Module-3/images/linq-statement.png)

### Разновидности LINQ

* **LINQ to Objects**: применяется для работы с массивами и коллекциями
* **Parallel LINQ (PLINQ)**: используется для выполнения параллельной запросов

## Практика

Есть класс компания, характеризующийся страной, названием, номером (счетчик). Набор компании хранится в 
List<Company>.

* Получить распределение компаний по странам
* Получить только номера компаний из Швеции
* Получить последнюю компанию

## Методы LINQ

* **Select**: определяет проекцию выбранных значений

* **Where**: определяет фильтр выборки

* **OrderBy**: упорядочивает элементы по возрастанию

* **OrderByDescending**: упорядочивает элементы по убыванию

* **ThenBy**: задает дополнительные критерии для упорядочивания элементов возрастанию

* **ThenByDescending**: задает дополнительные критерии для упорядочивания элементов по убыванию

* **Join**: соединяет две коллекции по определенному признаку

* **GroupBy**: группирует элементы по ключу

* **ToLookup**: группирует элементы по ключу, при этом все элементы добавляются в словарь

* **GroupJoin**: выполняет одновременно соединение коллекций и группировку элементов по ключу

* **Reverse**: располагает элементы в обратном порядке

* **All**: определяет, все ли элементы коллекции удовлятворяют определенному условию

* **Any**: определяет, удовлетворяет хотя бы один элемент коллекции определенному условию

* **Count**: подсчитывает количество элементов коллекции, которые удовлетворяют определенному условию

* **Sum**: подсчитывает сумму числовых значений в коллекции 

* **Average**: подсчитывает cреднее значение числовых значений в коллекции

* **Min**: находит минимальное значение

* **Max**: находит максимальное значение

* **Take**: выбирает определенное количество элементов

* **Skip**: пропускает определенное количество элементов

* **Contains**: определяет, содержит ли коллекция определенный элемент

* **Distinct**: удаляет дублирующиеся элементы из коллекции

* **Except**: возвращает разность двух коллекцию, то есть те элементы, которые содератся только в одной коллекции

* **Union**: объединяет две однородные коллекции

* **Intersect**: возвращает пересечение двух коллекций, то есть те элементы, которые встречаются в обоих коллекциях

* **TakeWhile**: возвращает цепочку элементов последовательности, до тех пор, пока условие истинно

* **SkipWhile**: пропускает элементы в последовательности, пока они удовлетворяют заданному условию, и затем возвращает оставшиеся элементы

* **Concat**: объединяет две коллекции

* **Zip**: объединяет две коллекции в соответствии с определенным условием

* **First**: выбирает первый элемент коллекции

* **FirstOrDefault**: выбирает первый элемент коллекции или возвращает значение по умолчанию

* **Single**: выбирает единственный элемент коллекции, если коллекция содердит больше или меньше одного элемента, то генерируется исключение

* **SingleOrDefault**: выбирает первый элемент коллекции или возвращает значение по умолчанию

* **ElementAt**: выбирает элемент последовательности по определенному индексу

* **ElementAtOrDefault**: выбирает элемент коллекции по определенному индексу или возвращает значение по умолчанию, если индекс вне допустимого диапазона

* **Last**: выбирает последний элемент коллекции

* **LastOrDefault**: выбирает последний элемент коллекции или возвращает значение по умолчанию

## Домашнее задание

1. Теория, знать методы как молитву.
2. Распределить задачи из https://github.com/YaroslavKuchuk/a-level/tree/master/Tasks/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B%20%D1%81%20%D0%BF%D1%80%D0%B8%D0%B2%D1%8F%D0%B7%D0%BA%D0%BE%D0%B9%20%D0%BA%20%D0%B4%D0%BE%D0%BC%D0%B5%D0%BD%D1%83
3. Практика

First, FirstOrDefault, last, LastOrDefault, Single

* Набор целых чисел (List). Показать первый положительный и последний отрицательный

* Расширим предыдущую задачу. Вернуть null в случае отсутствия одного из искомых элементов.

* Есть некоторый символ и есть набор строк. Если в наборе есть один элемент начинающийся с С, то показать его. Пустая строка - если таких элементов нет. Если таких строк несколько, то вернуть строку из них.

* Усложняем задание

- обработать ситуацию с ошибкой в предыдущем примере (когда она будет и почему)
- Реестр символа должен быть не важен.

Where, Distinct

* Есть набор чисел. Вернем все четные, удалим повторы

Reverse

* Есть число D и лист целых чисел. Найти первый элемент, больший чем D. Вернуть все четные и положительные числа, поменяв их порядок следования

Concat, DefaultIfEmpty

* Есть число. Есть два листа чисел. Сделать новый лист из элементов больших чем число (из первой последовательности) и элементов меньших числа (из второй). Если таких элементов нет - подставить некоторую константу.

GroupBy, ToDictionary

* Есть поставщики, и есть сумма за их поставки. Каждая поставка имеет дату.

string Name
double Amount
DateTime Date

сделать группированную коллекцию типа

- Name (key)
- value
   - Общая сумма поставок
   - Дата первой поставки
   - Дата последней поставки

* Не показывать "пустых" поставщиков
* Не показывать "пустых" поставщиков на этапе работе с исходной коллекцией